{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  };\n\n  function State(options) {\n    this.options = {};\n\n    for (var name in defaults) this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name];\n\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function (cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus);\n    }\n\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n\n      if (cm.hasFocus()) {\n        state.active = true;\n        highlightMatches(cm);\n      } else {\n        cm.on(\"focus\", onFocus);\n      }\n\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state);\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter;\n\n    if (!state.active) {\n      state.active = true;\n      scheduleHighlight(cm, state);\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      highlightMatches(cm);\n    }, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp((/\\w/.test(query.charAt(0)) ? \"\\\\b\" : \"\") + query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") + (/\\w/.test(query.charAt(query.length - 1)) ? \"\\\\b\" : \"\")) : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false, {\n        className: \"CodeMirror-selection-highlight-scrollbar\"\n      });\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function () {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(),\n            line = cm.getLine(cur.line),\n            start = cur.ch,\n            end = start;\n\n        while (start && re.test(line.charAt(start - 1))) --start;\n\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n\n        if (start < end) addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n\n      var from = cm.getCursor(\"from\"),\n          to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to);\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\");\n      if (selection.length >= state.options.minChars) addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n\n    if (str.match(/^\\w+$/) !== null) {\n      if (from.ch > 0) {\n        var pos = {\n          line: from.line,\n          ch: from.ch - 1\n        };\n        var chr = cm.getRange(pos, from);\n        if (chr.match(/\\W/) === null) return false;\n      }\n\n      if (to.ch < cm.getLine(from.line).length) {\n        var pos = {\n          line: to.line,\n          ch: to.ch + 1\n        };\n        var chr = cm.getRange(to, pos);\n        if (chr.match(/\\W/) === null) return false;\n      }\n\n      return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) && (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {\n      token: function (stream) {\n        if (stream.match(query) && (!hasBoundary || boundariesAround(stream, hasBoundary))) return style;\n        stream.next();\n        stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n      }\n    };\n  }\n});","map":{"version":3,"sources":["/Users/jevlopez/Documents/React-CodePen-Clone/node_modules/codemirror/addon/search/match-highlighter.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defaults","style","minChars","delay","wordsOnly","annotateScrollbar","showToken","trim","State","options","name","hasOwnProperty","overlay","timeout","matchesonscroll","active","defineOption","cm","val","old","Init","removeOverlay","clearTimeout","state","matchHighlighter","off","cursorActivity","onFocus","hasFocus","highlightMatches","on","scheduleHighlight","setTimeout","addOverlay","query","hasBoundary","makeOverlay","showMatchesOnScrollbar","searchFor","RegExp","test","charAt","replace","length","className","clear","operation","somethingSelected","re","cur","getCursor","line","getLine","start","ch","end","slice","from","to","isWord","selection","getRange","str","match","pos","chr","boundariesAround","stream","string","token","next","skipTo","skipToEnd"],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,CAAC,UAASA,GAAT,EAAc;AACb,MAAI,OAAOC,OAAP,IAAkB,QAAlB,IAA8B,OAAOC,MAAP,IAAiB,QAAnD,EAA6D;AAC3DF,IAAAA,GAAG,CAACG,OAAO,CAAC,sBAAD,CAAR,EAAkCA,OAAO,CAAC,sBAAD,CAAzC,CAAH,CADF,KAEK,IAAI,OAAOC,MAAP,IAAiB,UAAjB,IAA+BA,MAAM,CAACC,GAA1C,EAA+C;AAClDD,IAAAA,MAAM,CAAC,CAAC,sBAAD,EAAyB,sBAAzB,CAAD,EAAmDJ,GAAnD,CAAN,CADG,KAEA;AACHA,IAAAA,GAAG,CAACM,UAAD,CAAH;AACH,CAPD,EAOG,UAASA,UAAT,EAAqB;AACtB;;AAEA,MAAIC,QAAQ,GAAG;AACbC,IAAAA,KAAK,EAAE,gBADM;AAEbC,IAAAA,QAAQ,EAAE,CAFG;AAGbC,IAAAA,KAAK,EAAE,GAHM;AAIbC,IAAAA,SAAS,EAAE,KAJE;AAKbC,IAAAA,iBAAiB,EAAE,KALN;AAMbC,IAAAA,SAAS,EAAE,KANE;AAObC,IAAAA,IAAI,EAAE;AAPO,GAAf;;AAUA,WAASC,KAAT,CAAeC,OAAf,EAAwB;AACtB,SAAKA,OAAL,GAAe,EAAf;;AACA,SAAK,IAAIC,IAAT,IAAiBV,QAAjB,EACE,KAAKS,OAAL,CAAaC,IAAb,IAAqB,CAACD,OAAO,IAAIA,OAAO,CAACE,cAAR,CAAuBD,IAAvB,CAAX,GAA0CD,OAA1C,GAAoDT,QAArD,EAA+DU,IAA/D,CAArB;;AACF,SAAKE,OAAL,GAAe,KAAKC,OAAL,GAAe,IAA9B;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,MAAL,GAAc,KAAd;AACD;;AAEDhB,EAAAA,UAAU,CAACiB,YAAX,CAAwB,2BAAxB,EAAqD,KAArD,EAA4D,UAASC,EAAT,EAAaC,GAAb,EAAkBC,GAAlB,EAAuB;AACjF,QAAIA,GAAG,IAAIA,GAAG,IAAIpB,UAAU,CAACqB,IAA7B,EAAmC;AACjCC,MAAAA,aAAa,CAACJ,EAAD,CAAb;AACAK,MAAAA,YAAY,CAACL,EAAE,CAACM,KAAH,CAASC,gBAAT,CAA0BX,OAA3B,CAAZ;AACAI,MAAAA,EAAE,CAACM,KAAH,CAASC,gBAAT,GAA4B,IAA5B;AACAP,MAAAA,EAAE,CAACQ,GAAH,CAAO,gBAAP,EAAyBC,cAAzB;AACAT,MAAAA,EAAE,CAACQ,GAAH,CAAO,OAAP,EAAgBE,OAAhB;AACD;;AACD,QAAIT,GAAJ,EAAS;AACP,UAAIK,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAAT,GAA4B,IAAIhB,KAAJ,CAAUU,GAAV,CAAxC;;AACA,UAAID,EAAE,CAACW,QAAH,EAAJ,EAAmB;AACjBL,QAAAA,KAAK,CAACR,MAAN,GAAe,IAAf;AACAc,QAAAA,gBAAgB,CAACZ,EAAD,CAAhB;AACD,OAHD,MAGO;AACLA,QAAAA,EAAE,CAACa,EAAH,CAAM,OAAN,EAAeH,OAAf;AACD;;AACDV,MAAAA,EAAE,CAACa,EAAH,CAAM,gBAAN,EAAwBJ,cAAxB;AACD;AACF,GAlBD;;AAoBA,WAASA,cAAT,CAAwBT,EAAxB,EAA4B;AAC1B,QAAIM,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAArB;AACA,QAAID,KAAK,CAACR,MAAN,IAAgBE,EAAE,CAACW,QAAH,EAApB,EAAmCG,iBAAiB,CAACd,EAAD,EAAKM,KAAL,CAAjB;AACpC;;AAED,WAASI,OAAT,CAAiBV,EAAjB,EAAqB;AACnB,QAAIM,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAArB;;AACA,QAAI,CAACD,KAAK,CAACR,MAAX,EAAmB;AACjBQ,MAAAA,KAAK,CAACR,MAAN,GAAe,IAAf;AACAgB,MAAAA,iBAAiB,CAACd,EAAD,EAAKM,KAAL,CAAjB;AACD;AACF;;AAED,WAASQ,iBAAT,CAA2Bd,EAA3B,EAA+BM,KAA/B,EAAsC;AACpCD,IAAAA,YAAY,CAACC,KAAK,CAACV,OAAP,CAAZ;AACAU,IAAAA,KAAK,CAACV,OAAN,GAAgBmB,UAAU,CAAC,YAAW;AAACH,MAAAA,gBAAgB,CAACZ,EAAD,CAAhB;AAAsB,KAAnC,EAAqCM,KAAK,CAACd,OAAN,CAAcN,KAAnD,CAA1B;AACD;;AAED,WAAS8B,UAAT,CAAoBhB,EAApB,EAAwBiB,KAAxB,EAA+BC,WAA/B,EAA4ClC,KAA5C,EAAmD;AACjD,QAAIsB,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAArB;AACAP,IAAAA,EAAE,CAACgB,UAAH,CAAcV,KAAK,CAACX,OAAN,GAAgBwB,WAAW,CAACF,KAAD,EAAQC,WAAR,EAAqBlC,KAArB,CAAzC;;AACA,QAAIsB,KAAK,CAACd,OAAN,CAAcJ,iBAAd,IAAmCY,EAAE,CAACoB,sBAA1C,EAAkE;AAChE,UAAIC,SAAS,GAAGH,WAAW,GAAG,IAAII,MAAJ,CAAW,CAAC,KAAKC,IAAL,CAAUN,KAAK,CAACO,MAAN,CAAa,CAAb,CAAV,IAA6B,KAA7B,GAAqC,EAAtC,IACAP,KAAK,CAACQ,OAAN,CAAc,mBAAd,EAAmC,MAAnC,CADA,IAEC,KAAKF,IAAL,CAAUN,KAAK,CAACO,MAAN,CAAaP,KAAK,CAACS,MAAN,GAAe,CAA5B,CAAV,IAA4C,KAA5C,GAAoD,EAFrD,CAAX,CAAH,GAE0ET,KAFrG;AAGAX,MAAAA,KAAK,CAACT,eAAN,GAAwBG,EAAE,CAACoB,sBAAH,CAA0BC,SAA1B,EAAqC,KAArC,EACtB;AAACM,QAAAA,SAAS,EAAE;AAAZ,OADsB,CAAxB;AAED;AACF;;AAED,WAASvB,aAAT,CAAuBJ,EAAvB,EAA2B;AACzB,QAAIM,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAArB;;AACA,QAAID,KAAK,CAACX,OAAV,EAAmB;AACjBK,MAAAA,EAAE,CAACI,aAAH,CAAiBE,KAAK,CAACX,OAAvB;AACAW,MAAAA,KAAK,CAACX,OAAN,GAAgB,IAAhB;;AACA,UAAIW,KAAK,CAACT,eAAV,EAA2B;AACzBS,QAAAA,KAAK,CAACT,eAAN,CAAsB+B,KAAtB;AACAtB,QAAAA,KAAK,CAACT,eAAN,GAAwB,IAAxB;AACD;AACF;AACF;;AAED,WAASe,gBAAT,CAA0BZ,EAA1B,EAA8B;AAC5BA,IAAAA,EAAE,CAAC6B,SAAH,CAAa,YAAW;AACtB,UAAIvB,KAAK,GAAGN,EAAE,CAACM,KAAH,CAASC,gBAArB;AACAH,MAAAA,aAAa,CAACJ,EAAD,CAAb;;AACA,UAAI,CAACA,EAAE,CAAC8B,iBAAH,EAAD,IAA2BxB,KAAK,CAACd,OAAN,CAAcH,SAA7C,EAAwD;AACtD,YAAI0C,EAAE,GAAGzB,KAAK,CAACd,OAAN,CAAcH,SAAd,KAA4B,IAA5B,GAAmC,OAAnC,GAA6CiB,KAAK,CAACd,OAAN,CAAcH,SAApE;AACA,YAAI2C,GAAG,GAAGhC,EAAE,CAACiC,SAAH,EAAV;AAAA,YAA0BC,IAAI,GAAGlC,EAAE,CAACmC,OAAH,CAAWH,GAAG,CAACE,IAAf,CAAjC;AAAA,YAAuDE,KAAK,GAAGJ,GAAG,CAACK,EAAnE;AAAA,YAAuEC,GAAG,GAAGF,KAA7E;;AACA,eAAOA,KAAK,IAAIL,EAAE,CAACR,IAAH,CAAQW,IAAI,CAACV,MAAL,CAAYY,KAAK,GAAG,CAApB,CAAR,CAAhB,EAAiD,EAAEA,KAAF;;AACjD,eAAOE,GAAG,GAAGJ,IAAI,CAACR,MAAX,IAAqBK,EAAE,CAACR,IAAH,CAAQW,IAAI,CAACV,MAAL,CAAYc,GAAZ,CAAR,CAA5B,EAAuD,EAAEA,GAAF;;AACvD,YAAIF,KAAK,GAAGE,GAAZ,EACEtB,UAAU,CAAChB,EAAD,EAAKkC,IAAI,CAACK,KAAL,CAAWH,KAAX,EAAkBE,GAAlB,CAAL,EAA6BP,EAA7B,EAAiCzB,KAAK,CAACd,OAAN,CAAcR,KAA/C,CAAV;AACF;AACD;;AACD,UAAIwD,IAAI,GAAGxC,EAAE,CAACiC,SAAH,CAAa,MAAb,CAAX;AAAA,UAAiCQ,EAAE,GAAGzC,EAAE,CAACiC,SAAH,CAAa,IAAb,CAAtC;AACA,UAAIO,IAAI,CAACN,IAAL,IAAaO,EAAE,CAACP,IAApB,EAA0B;AAC1B,UAAI5B,KAAK,CAACd,OAAN,CAAcL,SAAd,IAA2B,CAACuD,MAAM,CAAC1C,EAAD,EAAKwC,IAAL,EAAWC,EAAX,CAAtC,EAAsD;AACtD,UAAIE,SAAS,GAAG3C,EAAE,CAAC4C,QAAH,CAAYJ,IAAZ,EAAkBC,EAAlB,CAAhB;AACA,UAAInC,KAAK,CAACd,OAAN,CAAcF,IAAlB,EAAwBqD,SAAS,GAAGA,SAAS,CAAClB,OAAV,CAAkB,YAAlB,EAAgC,EAAhC,CAAZ;AACxB,UAAIkB,SAAS,CAACjB,MAAV,IAAoBpB,KAAK,CAACd,OAAN,CAAcP,QAAtC,EACE+B,UAAU,CAAChB,EAAD,EAAK2C,SAAL,EAAgB,KAAhB,EAAuBrC,KAAK,CAACd,OAAN,CAAcR,KAArC,CAAV;AACH,KAnBD;AAoBD;;AAED,WAAS0D,MAAT,CAAgB1C,EAAhB,EAAoBwC,IAApB,EAA0BC,EAA1B,EAA8B;AAC5B,QAAII,GAAG,GAAG7C,EAAE,CAAC4C,QAAH,CAAYJ,IAAZ,EAAkBC,EAAlB,CAAV;;AACA,QAAII,GAAG,CAACC,KAAJ,CAAU,OAAV,MAAuB,IAA3B,EAAiC;AAC7B,UAAIN,IAAI,CAACH,EAAL,GAAU,CAAd,EAAiB;AACb,YAAIU,GAAG,GAAG;AAACb,UAAAA,IAAI,EAAEM,IAAI,CAACN,IAAZ;AAAkBG,UAAAA,EAAE,EAAEG,IAAI,CAACH,EAAL,GAAU;AAAhC,SAAV;AACA,YAAIW,GAAG,GAAGhD,EAAE,CAAC4C,QAAH,CAAYG,GAAZ,EAAiBP,IAAjB,CAAV;AACA,YAAIQ,GAAG,CAACF,KAAJ,CAAU,IAAV,MAAoB,IAAxB,EAA8B,OAAO,KAAP;AACjC;;AACD,UAAIL,EAAE,CAACJ,EAAH,GAAQrC,EAAE,CAACmC,OAAH,CAAWK,IAAI,CAACN,IAAhB,EAAsBR,MAAlC,EAA0C;AACtC,YAAIqB,GAAG,GAAG;AAACb,UAAAA,IAAI,EAAEO,EAAE,CAACP,IAAV;AAAgBG,UAAAA,EAAE,EAAEI,EAAE,CAACJ,EAAH,GAAQ;AAA5B,SAAV;AACA,YAAIW,GAAG,GAAGhD,EAAE,CAAC4C,QAAH,CAAYH,EAAZ,EAAgBM,GAAhB,CAAV;AACA,YAAIC,GAAG,CAACF,KAAJ,CAAU,IAAV,MAAoB,IAAxB,EAA8B,OAAO,KAAP;AACjC;;AACD,aAAO,IAAP;AACH,KAZD,MAYO,OAAO,KAAP;AACR;;AAED,WAASG,gBAAT,CAA0BC,MAA1B,EAAkCnB,EAAlC,EAAsC;AACpC,WAAO,CAAC,CAACmB,MAAM,CAACd,KAAR,IAAiB,CAACL,EAAE,CAACR,IAAH,CAAQ2B,MAAM,CAACC,MAAP,CAAc3B,MAAd,CAAqB0B,MAAM,CAACd,KAAP,GAAe,CAApC,CAAR,CAAnB,MACJc,MAAM,CAACH,GAAP,IAAcG,MAAM,CAACC,MAAP,CAAczB,MAA5B,IAAsC,CAACK,EAAE,CAACR,IAAH,CAAQ2B,MAAM,CAACC,MAAP,CAAc3B,MAAd,CAAqB0B,MAAM,CAACH,GAA5B,CAAR,CADnC,CAAP;AAED;;AAED,WAAS5B,WAAT,CAAqBF,KAArB,EAA4BC,WAA5B,EAAyClC,KAAzC,EAAgD;AAC9C,WAAO;AAACoE,MAAAA,KAAK,EAAE,UAASF,MAAT,EAAiB;AAC9B,YAAIA,MAAM,CAACJ,KAAP,CAAa7B,KAAb,MACC,CAACC,WAAD,IAAgB+B,gBAAgB,CAACC,MAAD,EAAShC,WAAT,CADjC,CAAJ,EAEE,OAAOlC,KAAP;AACFkE,QAAAA,MAAM,CAACG,IAAP;AACAH,QAAAA,MAAM,CAACI,MAAP,CAAcrC,KAAK,CAACO,MAAN,CAAa,CAAb,CAAd,KAAkC0B,MAAM,CAACK,SAAP,EAAlC;AACD;AANM,KAAP;AAOD;AACF,CAjJD","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./matchesonscrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./matchesonscrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n    this.active = false;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n      cm.off(\"focus\", onFocus)\n    }\n    if (val) {\n      var state = cm.state.matchHighlighter = new State(val);\n      if (cm.hasFocus()) {\n        state.active = true\n        highlightMatches(cm)\n      } else {\n        cm.on(\"focus\", onFocus)\n      }\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.active || cm.hasFocus()) scheduleHighlight(cm, state)\n  }\n\n  function onFocus(cm) {\n    var state = cm.state.matchHighlighter\n    if (!state.active) {\n      state.active = true\n      scheduleHighlight(cm, state)\n    }\n  }\n\n  function scheduleHighlight(cm, state) {\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp((/\\w/.test(query.charAt(0)) ? \"\\\\b\" : \"\") +\n                                               query.replace(/[\\\\\\[.+*?(){|^$]/g, \"\\\\$&\") +\n                                               (/\\w/.test(query.charAt(query.length - 1)) ? \"\\\\b\" : \"\")) : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n"]},"metadata":{},"sourceType":"script"}
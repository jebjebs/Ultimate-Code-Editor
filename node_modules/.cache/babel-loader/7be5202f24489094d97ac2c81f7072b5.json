{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function (query, caseFold, options) {\n    if (typeof options == \"string\") options = {\n      className: options\n    };\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {\n      listenForChanges: false\n    };\n\n    for (var prop in options) annotateOptions[prop] = options[prop];\n\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {\n      from: cm.firstLine(),\n      to: cm.lastLine() + 1\n    };\n    this.matches = [];\n    this.update = null;\n    this.findMatches();\n    this.annotation.update(this.matches);\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function (_cm, change) {\n      self.onChange(change);\n    });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function () {\n    if (!this.gap) return;\n\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), {\n      caseFold: this.caseFold,\n      multiline: this.options.multiline\n    });\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n\n    while (cursor.findNext()) {\n      var match = {\n        from: cursor.from(),\n        to: cursor.to()\n      };\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function (change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {\n        from: change.from.line,\n        to: endLine + 1\n      };\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function () {\n      self.updateAfterChange();\n    }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function () {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function () {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});","map":{"version":3,"sources":["/Users/jevlopez/Documents/React-CodePen-Clone/node_modules/codemirror/addon/search/matchesonscrollbar.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineExtension","query","caseFold","options","className","SearchAnnotation","cm","annotateOptions","listenForChanges","prop","annotation","annotateScrollbar","gap","from","firstLine","to","lastLine","matches","update","findMatches","self","on","changeHandler","_cm","change","onChange","MAX_MATCHES","prototype","i","length","match","line","splice","cursor","getSearchCursor","Pos","multiline","maxMatches","findNext","offsetLine","changeStart","sizeChange","Math","max","startLine","endLine","changeEnd","min","newFrom","ch","newTo","clearTimeout","setTimeout","updateAfterChange","clear","off"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), {caseFold: this.caseFold, multiline: this.options.multiline});\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n"]},"metadata":{},"sourceType":"script"}